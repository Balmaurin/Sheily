"""
Script de Inicializaci√≥n de M√≥dulos para Shaili AI
=================================================

Este script inicializa y valida todos los m√≥dulos del sistema,
asegurando que est√©n disponibles para el LLM.
"""

import asyncio
import logging
import json
import sys
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime

# Configurar logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Importar el sistema de m√≥dulos
try:
    from . import UnifiedModuleSystem, initialize_modules, get_module, list_modules
    from .module_router import (
        LLMModuleInterface,
        call_module,
        get_modules,
        get_module_docs,
    )
except ImportError as e:
    logger.error(f"Error importando m√≥dulos: {e}")
    sys.exit(1)


class ModuleInitializer:
    """Inicializador y validador de m√≥dulos"""

    def __init__(self):
        self.system = UnifiedModuleSystem()
        self.llm_interface = LLMModuleInterface()
        self.initialization_report = {
            "timestamp": datetime.now().isoformat(),
            "total_modules": 0,
            "successful_modules": 0,
            "failed_modules": 0,
            "module_details": {},
            "categories": {},
            "errors": [],
        }

    async def initialize_all_modules(self) -> Dict[str, Any]:
        """Inicializar todos los m√≥dulos del sistema"""
        logger.info("üöÄ Iniciando inicializaci√≥n completa del sistema de m√≥dulos...")

        start_time = datetime.now()

        try:
            # Inicializar el sistema principal
            await self.system.initialize()

            # Inicializar la interfaz del LLM
            await self.llm_interface.initialize()

            # Generar reporte de inicializaci√≥n
            await self._generate_initialization_report()

            # Validar m√≥dulos cr√≠ticos
            await self._validate_critical_modules()

            # Probar funcionalidad b√°sica
            await self._test_basic_functionality()

            end_time = datetime.now()
            initialization_time = (end_time - start_time).total_seconds()

            self.initialization_report["initialization_time"] = initialization_time
            self.initialization_report["status"] = "completed"

            logger.info(
                f"‚úÖ Inicializaci√≥n completada en {initialization_time:.2f} segundos"
            )
            logger.info(
                f"üìä M√≥dulos cargados: {self.initialization_report['successful_modules']}/{self.initialization_report['total_modules']}"
            )

            return self.initialization_report

        except Exception as e:
            logger.error(f"‚ùå Error durante la inicializaci√≥n: {e}")
            self.initialization_report["status"] = "failed"
            self.initialization_report["errors"].append(str(e))
            return self.initialization_report

    async def _generate_initialization_report(self):
        """Generar reporte detallado de inicializaci√≥n"""
        logger.info("üìã Generando reporte de inicializaci√≥n...")

        # Obtener informaci√≥n de todos los m√≥dulos
        all_modules = self.system.registry.modules
        categories = self.system.registry.categories

        self.initialization_report["total_modules"] = len(all_modules)
        self.initialization_report["categories"] = categories

        for module_name, module_info in all_modules.items():
            try:
                # Verificar que el m√≥dulo se puede instanciar
                module_instance = self.system.get_module(module_name)

                if module_instance:
                    self.initialization_report["successful_modules"] += 1
                    status = "active"
                else:
                    self.initialization_report["failed_modules"] += 1
                    status = "failed"

                self.initialization_report["module_details"][module_name] = {
                    "category": module_info.category,
                    "description": module_info.description,
                    "class": module_info.class_name,
                    "status": status,
                    "dependencies": module_info.dependencies,
                    "is_async": module_info.is_async,
                }

            except Exception as e:
                self.initialization_report["failed_modules"] += 1
                self.initialization_report["module_details"][module_name] = {
                    "category": module_info.category,
                    "description": module_info.description,
                    "class": module_info.class_name,
                    "status": "error",
                    "error": str(e),
                }
                self.initialization_report["errors"].append(
                    f"Error en {module_name}: {e}"
                )

    async def _validate_critical_modules(self):
        """Validar m√≥dulos cr√≠ticos del sistema"""
        logger.info("üîç Validando m√≥dulos cr√≠ticos...")

        critical_modules = [
            "text_processor",
            "semantic_analyzer",
            "llm_manager",
            "response_generator",
            "rag_retriever",
            "data_management",
        ]

        for module_name in critical_modules:
            try:
                module_info = self.system.get_module_info(module_name)
                if module_info and module_info["status"] == "active":
                    logger.info(f"‚úÖ M√≥dulo cr√≠tico '{module_name}' validado")
                else:
                    logger.warning(f"‚ö†Ô∏è M√≥dulo cr√≠tico '{module_name}' no disponible")
                    self.initialization_report["errors"].append(
                        f"M√≥dulo cr√≠tico '{module_name}' no disponible"
                    )
            except Exception as e:
                logger.error(f"‚ùå Error validando m√≥dulo cr√≠tico '{module_name}': {e}")
                self.initialization_report["errors"].append(
                    f"Error validando '{module_name}': {e}"
                )

    async def _test_basic_functionality(self):
        """Probar funcionalidad b√°sica de los m√≥dulos"""
        logger.info("üß™ Probando funcionalidad b√°sica...")

        # Probar procesamiento de texto
        try:
            result = await call_module(
                "text_processor", "clean_text", text="  Hola mundo!  "
            )
            if result["success"]:
                logger.info("‚úÖ Procesamiento de texto funcionando")
            else:
                logger.warning(f"‚ö†Ô∏è Error en procesamiento de texto: {result['error']}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo probar procesamiento de texto: {e}")

        # Probar an√°lisis sem√°ntico
        try:
            result = await call_module(
                "semantic_analyzer",
                "calculate_similarity",
                text1="Hola mundo",
                text2="Hello world",
            )
            if result["success"]:
                logger.info("‚úÖ An√°lisis sem√°ntico funcionando")
            else:
                logger.warning(f"‚ö†Ô∏è Error en an√°lisis sem√°ntico: {result['error']}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo probar an√°lisis sem√°ntico: {e}")

    def save_report(self, output_path: str = "module_initialization_report.json"):
        """Guardar reporte de inicializaci√≥n"""
        try:
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(
                    self.initialization_report,
                    f,
                    indent=2,
                    default=str,
                    ensure_ascii=False,
                )
            logger.info(f"üìÑ Reporte guardado en: {output_path}")
        except Exception as e:
            logger.error(f"‚ùå Error guardando reporte: {e}")

    def print_summary(self):
        """Imprimir resumen de inicializaci√≥n"""
        report = self.initialization_report

        print("\n" + "=" * 60)
        print("üìä RESUMEN DE INICIALIZACI√ìN DE M√ìDULOS")
        print("=" * 60)
        print(f"üïí Timestamp: {report['timestamp']}")
        print(f"üì¶ Total de m√≥dulos: {report['total_modules']}")
        print(f"‚úÖ M√≥dulos exitosos: {report['successful_modules']}")
        print(f"‚ùå M√≥dulos fallidos: {report['failed_modules']}")
        print(
            f"‚è±Ô∏è Tiempo de inicializaci√≥n: {report.get('initialization_time', 'N/A')} segundos"
        )

        if report["categories"]:
            print(f"\nüìÇ Categor√≠as disponibles ({len(report['categories'])}):")
            for category, modules in report["categories"].items():
                print(f"  ‚Ä¢ {category}: {len(modules)} m√≥dulos")

        if report["errors"]:
            print(f"\n‚ùå Errores encontrados ({len(report['errors'])}):")
            for error in report["errors"][:5]:  # Mostrar solo los primeros 5
                print(f"  ‚Ä¢ {error}")
            if len(report["errors"]) > 5:
                print(f"  ... y {len(report['errors']) - 5} errores m√°s")

        print("=" * 60)

    def get_module_status(self, module_name: str) -> Dict[str, Any]:
        """Obtener estado de un m√≥dulo espec√≠fico"""
        return self.initialization_report["module_details"].get(module_name, {})

    def get_category_modules(self, category: str) -> List[Dict[str, Any]]:
        """Obtener m√≥dulos de una categor√≠a espec√≠fica"""
        modules = []
        for module_name, details in self.initialization_report[
            "module_details"
        ].items():
            if details.get("category") == category:
                modules.append({"name": module_name, **details})
        return modules


async def main():
    """Funci√≥n principal de inicializaci√≥n"""
    print("üöÄ Inicializando Sistema de M√≥dulos Shaili AI")
    print("=" * 50)

    # Crear inicializador
    initializer = ModuleInitializer()

    # Inicializar todos los m√≥dulos
    report = await initializer.initialize_all_modules()

    # Imprimir resumen
    initializer.print_summary()

    # Guardar reporte
    initializer.save_report()

    # Verificar si la inicializaci√≥n fue exitosa
    if report["status"] == "completed" and report["failed_modules"] == 0:
        print("\nüéâ ¬°Inicializaci√≥n completada exitosamente!")
        return True
    elif report["status"] == "completed":
        print(
            f"\n‚ö†Ô∏è Inicializaci√≥n completada con {report['failed_modules']} m√≥dulos fallidos"
        )
        return False
    else:
        print("\n‚ùå La inicializaci√≥n fall√≥")
        return False


def quick_status():
    """Funci√≥n r√°pida para verificar el estado del sistema"""
    try:
        # Verificar si el sistema est√° disponible
        modules = get_modules()
        total_modules = sum(len(module_list) for module_list in modules.values())

        print(f"üì¶ Sistema de m√≥dulos disponible")
        print(f"üìä Total de m√≥dulos: {total_modules}")
        print(f"üìÇ Categor√≠as: {list(modules.keys())}")

        return True
    except Exception as e:
        print(f"‚ùå Sistema de m√≥dulos no disponible: {e}")
        return False


if __name__ == "__main__":
    # Ejecutar inicializaci√≥n completa
    success = asyncio.run(main())

    if success:
        print("\n‚úÖ El sistema est√° listo para usar")
        sys.exit(0)
    else:
        print("\n‚ùå El sistema tiene problemas")
        sys.exit(1)
