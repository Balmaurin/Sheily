#!/usr/bin/env python3
"""
Script de Preparaci√≥n para Producci√≥n - VERSI√ìN COMPLETA
=======================================================

Prepara el sistema NeuroFusion para producci√≥n ejecutando verificaciones
completas de todos los componentes cr√≠ticos.
"""

import os
import sys
import subprocess
import json
import requests
import time
from pathlib import Path
from datetime import datetime
import importlib.util


class ProductionPreparer:
    def __init__(self):
        self.project_root = Path.cwd()
        self.results = {}
        self.start_time = datetime.now()

    def run_command(self, command, description, timeout=60):
        """Ejecuta un comando y registra el resultado"""
        print(f"üîß {description}...")
        try:
            result = subprocess.run(
                command, shell=True, capture_output=True, text=True, timeout=timeout
            )
            if result.returncode == 0:
                print(f"‚úÖ {description} - EXITOSO")
                return True, result.stdout
            else:
                print(f"‚ùå {description} - FALL√ì")
                print(f"Error: {result.stderr}")
                return False, result.stderr
        except subprocess.TimeoutExpired:
            print(f"‚è∞ {description} - TIMEOUT")
            return False, "Timeout"
        except Exception as e:
            print(f"‚ùå {description} - ERROR: {e}")
            return False, str(e)

    def verify_dependencies(self):
        """Verifica todas las dependencias cr√≠ticas"""
        print("üì¶ Verificando dependencias del sistema...")

        # Dependencias Python cr√≠ticas
        python_deps = [
            "torch",
            "transformers",
            "numpy",
            "pandas",
            "fastapi",
            "uvicorn",
            "sqlalchemy",
            "redis",
            "psutil",
            "requests",
            "aiohttp",
            "asyncio",
            "pydantic",
            "python-multipart",
            "python-jose",
            "passlib",
            "bcrypt",
            "prometheus_client",
            "faiss-cpu",
            "scikit-learn",
        ]

        # Dependencias del sistema
        system_deps = ["docker", "docker-compose", "node", "npm", "git", "curl"]

        all_ok = True

        # Verificar dependencias Python
        for dep in python_deps:
            try:
                importlib.import_module(dep)
                print(f"‚úÖ Python: {dep}")
            except ImportError:
                print(f"‚ùå Python: {dep} - NO INSTALADO")
                all_ok = False

        # Verificar dependencias del sistema
        for dep in system_deps:
            success, _ = self.run_command(
                f"which {dep}", f"Verificando {dep}", timeout=5
            )
            if not success:
                all_ok = False

        return all_ok

    def verify_llm_models(self):
        """Verifica los modelos de LLM y su disponibilidad"""
        print("ü§ñ Verificando modelos de LLM...")

        # Verificar modelos T5
        t5_models = ["t5-large"]

        all_ok = True

        try:
            from transformers import AutoTokenizer, AutoModel

            for model_name in t5_models:
                try:
                    print(f"üîç Verificando modelo {model_name}...")
                    tokenizer = AutoTokenizer.from_pretrained(model_name)
                    model = AutoModel.from_pretrained(model_name)

                    # Prueba b√°sica de inferencia
                    test_text = "Hello world"
                    inputs = tokenizer(test_text, return_tensors="pt")
                    outputs = model(**inputs)

                    print(f"‚úÖ {model_name} - Funcional")
                except Exception as e:
                    print(f"‚ùå {model_name} - Error: {e}")
                    all_ok = False

        except ImportError:
            print("‚ùå Transformers no disponible")
            all_ok = False

        # Verificar modelo principal
        try:
            from transformers import AutoModel, AutoTokenizer

            model_path = "models/custom/shaili-personal-model"
            tokenizer = AutoTokenizer.from_pretrained(model_path)
            model = AutoModel.from_pretrained(model_path)
            print(f"‚úÖ Modelo principal: {model_path} - Funcional")
        except Exception as e:
            print(f"‚ùå Modelo principal: {model_path} - Error: {e}")
            all_ok = False

        return all_ok

    def verify_backend_functionality(self):
        """Verifica la funcionalidad del backend"""
        print("üîß Verificando funcionalidad del backend...")

        backend_dir = self.project_root / "interface" / "backend"

        if not backend_dir.exists():
            print("‚ùå Directorio backend no encontrado")
            return False

        all_ok = True

        # Verificar archivos cr√≠ticos del backend
        critical_files = ["main.py", "requirements.txt", "config.env", ".env"]

        for file_name in critical_files:
            file_path = backend_dir / file_name
            if file_path.exists():
                size = file_path.stat().st_size
                print(f"‚úÖ {file_name} - {size} bytes")
            else:
                print(f"‚ùå {file_name} - No encontrado")
                all_ok = False

        # Verificar que el backend puede iniciar
        try:
            # Cambiar al directorio backend
            original_cwd = os.getcwd()
            os.chdir(backend_dir)

            # Verificar dependencias del backend
            success, _ = self.run_command(
                "pip install -r requirements.txt",
                "Instalando dependencias del backend",
                timeout=120,
            )

            # Intentar iniciar el servidor en modo de prueba
            success, _ = self.run_command(
                "python -c 'import uvicorn; print(\"Uvicorn disponible\")'",
                "Verificando Uvicorn",
                timeout=10,
            )

            os.chdir(original_cwd)

            if not success:
                all_ok = False

        except Exception as e:
            print(f"‚ùå Error verificando backend: {e}")
            all_ok = False

        return all_ok

    def verify_frontend_functionality(self):
        """Verifica la funcionalidad del frontend"""
        print("üé® Verificando funcionalidad del frontend...")

        frontend_dir = self.project_root / "interface" / "frontend"

        if not frontend_dir.exists():
            print("‚ùå Directorio frontend no encontrado")
            return False

        all_ok = True

        # Verificar archivos cr√≠ticos del frontend
        critical_files = [
            "package.json",
            "package-lock.json",
            "src/App.js",
            "public/index.html",
        ]

        for file_name in critical_files:
            file_path = frontend_dir / file_name
            if file_path.exists():
                size = file_path.stat().st_size
                print(f"‚úÖ {file_name} - {size} bytes")
            else:
                print(f"‚ùå {file_name} - No encontrado")
                all_ok = False

        # Verificar dependencias de Node.js
        try:
            original_cwd = os.getcwd()
            os.chdir(frontend_dir)

            # Verificar que npm est√° disponible
            success, _ = self.run_command(
                "npm --version", "Verificando npm", timeout=10
            )

            if success:
                # Verificar que las dependencias est√°n instaladas
                if (frontend_dir / "node_modules").exists():
                    print("‚úÖ node_modules - Instalado")
                else:
                    print("‚ö†Ô∏è node_modules - No encontrado, instalando...")
                    success, _ = self.run_command(
                        "npm install",
                        "Instalando dependencias del frontend",
                        timeout=180,
                    )
                    if not success:
                        all_ok = False
            else:
                all_ok = False

            os.chdir(original_cwd)

        except Exception as e:
            print(f"‚ùå Error verificando frontend: {e}")
            all_ok = False

        return all_ok

    def verify_training_systems(self):
        """Verifica los sistemas de entrenamiento"""
        print("üèãÔ∏è Verificando sistemas de entrenamiento...")

        all_ok = True

        # Verificar directorios de entrenamiento
        training_dirs = ["modules/training", "models", "data"]

        for dir_name in training_dirs:
            dir_path = self.project_root / dir_name
            if dir_path.exists():
                file_count = len(list(dir_path.rglob("*.py")))
                print(f"‚úÖ {dir_name} - {file_count} archivos Python")
            else:
                print(f"‚ùå {dir_name} - No encontrado")
                all_ok = False

        # Verificar configuraciones de entrenamiento
        training_configs = [
            "config/advanced_training_config.json",
            "config/config/neurofusion_config.json",
        ]

        for config_file in training_configs:
            config_path = self.project_root / config_file
            if config_path.exists():
                try:
                    with open(config_path, "r") as f:
                        config = json.load(f)

                    # Verificar que tiene configuraciones de entrenamiento
                    if "training" in str(config) or "model" in str(config):
                        size = config_path.stat().st_size
                        print(f"‚úÖ {config_file} - {size} bytes")
                    else:
                        print(f"‚ö†Ô∏è {config_file} - Sin configuraciones de entrenamiento")
                except Exception as e:
                    print(f"‚ùå {config_file} - Error: {e}")
                    all_ok = False
            else:
                print(f"‚ùå {config_file} - No encontrado")
                all_ok = False

        # Verificar que los m√≥dulos de entrenamiento importan
        training_modules = [
            "modules.training",
            "modules.learning",
            "modules.evaluation",
        ]

        for module in training_modules:
            try:
                result = subprocess.run(
                    f'python3 -c \'import sys; sys.path.append("."); import {module}; print("OK")\'',
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )
                if result.returncode == 0 and "OK" in result.stdout:
                    print(f"‚úÖ {module} - Importa correctamente")
                else:
                    print(f"‚ùå {module} - Error al importar")
                    all_ok = False
            except Exception as e:
                print(f"‚ùå {module} - Error: {e}")
                all_ok = False

        return all_ok

    def verify_endpoints(self):
        """Verifica endpoints y APIs"""
        print("üåê Verificando endpoints y APIs...")

        all_ok = True

        # Verificar que el backend puede iniciar y responder
        backend_dir = self.project_root / "interface" / "backend"

        if backend_dir.exists():
            try:
                # Intentar iniciar el servidor en background
                original_cwd = os.getcwd()
                os.chdir(backend_dir)

                # Verificar si hay un servidor ya corriendo
                success, _ = self.run_command(
                    "curl -s http://localhost:8000/health || echo 'No response'",
                    "Verificando servidor backend",
                    timeout=5,
                )

                if "No response" in success:
                    print("‚ö†Ô∏è Backend no est√° corriendo, intentando iniciar...")

                    # Intentar iniciar el servidor
                    success, _ = self.run_command(
                        "python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload &",
                        "Iniciando servidor backend",
                        timeout=10,
                    )

                    if success:
                        # Esperar a que el servidor inicie
                        time.sleep(5)

                        # Verificar endpoints
                        endpoints = [
                            ("http://localhost:8000/health", "Health Check"),
                            ("http://localhost:8000/docs", "API Documentation"),
                            ("http://localhost:8000/", "Root Endpoint"),
                        ]

                        for url, description in endpoints:
                            try:
                                response = requests.get(url, timeout=5)
                                if response.status_code == 200:
                                    print(f"‚úÖ {description} - {response.status_code}")
                                else:
                                    print(f"‚ö†Ô∏è {description} - {response.status_code}")
                            except Exception as e:
                                print(f"‚ùå {description} - Error: {e}")
                                all_ok = False

                        # Detener el servidor
                        self.run_command(
                            "pkill -f uvicorn", "Deteniendo servidor backend"
                        )
                    else:
                        all_ok = False
                else:
                    print("‚úÖ Backend ya est√° corriendo")

                os.chdir(original_cwd)

            except Exception as e:
                print(f"‚ùå Error verificando endpoints: {e}")
                all_ok = False
        else:
            print("‚ùå Directorio backend no encontrado")
            all_ok = False

        return all_ok

    def verify_database_initialization(self):
        """Verifica que las bases de datos est√©n inicializadas"""
        print("üîç Verificando inicializaci√≥n de bases de datos...")

        databases = [
            ("data/knowledge_base.db", "knowledge_base"),
            ("data/embeddings_sqlite.db", "embeddings"),
            ("data/rag_memory.duckdb", "rag_memory"),
            ("data/user_data.duckdb", "users"),
            ("monitoring/metrics.db", "metrics"),
        ]

        all_ok = True
        for db_path, table_name in databases:
            if os.path.exists(db_path):
                try:
                    result = subprocess.run(
                        f"sqlite3 {db_path} 'SELECT COUNT(*) FROM {table_name};'",
                        shell=True,
                        capture_output=True,
                        text=True,
                    )
                    if result.returncode == 0:
                        count = int(result.stdout.strip())
                        if count > 0:
                            print(f"‚úÖ {db_path} - {count} registros")
                        else:
                            print(f"‚ö†Ô∏è {db_path} - 0 registros")
                            all_ok = False
                    else:
                        print(f"‚ùå {db_path} - Error al verificar")
                        all_ok = False
                except Exception as e:
                    print(f"‚ùå {db_path} - Error: {e}")
                    all_ok = False
            else:
                print(f"‚ùå {db_path} - No existe")
                all_ok = False

        # Verificar √≠ndice FAISS
        if os.path.exists("data/faiss_index.index"):
            size = os.path.getsize("data/faiss_index.index")
            if size > 1000000:  # M√°s de 1MB
                print(f"‚úÖ data/faiss_index.index - {size/1024/1024:.1f}MB")
            else:
                print(f"‚ö†Ô∏è data/faiss_index.index - Muy peque√±o ({size} bytes)")
                all_ok = False
        else:
            print("‚ùå data/faiss_index.index - No existe")
            all_ok = False

        return all_ok

    def verify_docker_setup(self):
        """Verifica la configuraci√≥n de Docker"""
        print("üê≥ Verificando configuraci√≥n de Docker...")

        docker_files = [
            "docker/docker-compose.yml",
            "docker/docker-compose.dev.yml",
            "docker/Dockerfile",
            "docker/backend.docker/Dockerfile",
            "docker/frontend.docker/Dockerfile",
        ]

        all_ok = True
        for file_path in docker_files:
            if os.path.exists(file_path):
                size = os.path.getsize(file_path)
                print(f"‚úÖ {file_path} - {size} bytes")
            else:
                print(f"‚ùå {file_path} - No existe")
                all_ok = False

        # Verificar que Docker est√° disponible
        success, _ = self.run_command(
            "docker --version", "Verificando Docker", timeout=10
        )
        if not success:
            all_ok = False

        # Verificar que docker-compose est√° disponible
        success, _ = self.run_command(
            "docker-compose --version", "Verificando docker-compose", timeout=10
        )
        if not success:
            all_ok = False

        return all_ok

    def verify_script_functionality(self):
        """Verifica que los scripts funcionen correctamente"""
        print("üîß Verificando funcionalidad de scripts...")

        scripts = [
            ("./scripts/verificar_sistema.sh", "Script de verificaci√≥n del sistema"),
            (
                "python3 scripts/initialize_databases.py",
                "Script de inicializaci√≥n de bases de datos",
            ),
        ]

        all_ok = True
        for script, description in scripts:
            success, output = self.run_command(script, description, timeout=30)
            if not success:
                all_ok = False

        return all_ok

    def verify_module_imports(self):
        """Verifica que los m√≥dulos principales importen correctamente"""
        print("üì¶ Verificando importaciones de m√≥dulos...")

        modules = [
            "modules.core.neurofusion_core",
            "modules.ai",
            "modules.unified_systems.module_initializer",
            "modules.nucleo_central.config.rate_limits",
            "modules.training",
            "modules.evaluation",
            "modules.memory",
            "modules.security",
        ]

        all_ok = True
        for module in modules:
            try:
                result = subprocess.run(
                    f'python3 -c \'import sys; sys.path.append("."); import {module}; print("OK")\'',
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=15,
                )
                if result.returncode == 0 and "OK" in result.stdout:
                    print(f"‚úÖ {module} - Importa correctamente")
                else:
                    print(f"‚ùå {module} - Error al importar")
                    all_ok = False
            except Exception as e:
                print(f"‚ùå {module} - Error: {e}")
                all_ok = False

        return all_ok

    def verify_configurations(self):
        """Verifica que las configuraciones sean v√°lidas"""
        print("‚öôÔ∏è Verificando configuraciones...")

        config_files = [
            "config/config/neurofusion_config.json",
            "config/rate_limits.json",
            "config/advanced_training_config.json",
            "config/config/module_initialization.json",
        ]

        all_ok = True
        for config_file in config_files:
            if os.path.exists(config_file):
                try:
                    with open(config_file, "r") as f:
                        config = json.load(f)
                    size = os.path.getsize(config_file)
                    print(f"‚úÖ {config_file} - JSON v√°lido ({size} bytes)")
                except json.JSONDecodeError as e:
                    print(f"‚ùå {config_file} - JSON inv√°lido: {e}")
                    all_ok = False
                except Exception as e:
                    print(f"‚ùå {config_file} - Error: {e}")
                    all_ok = False
            else:
                print(f"‚ùå {config_file} - No existe")
                all_ok = False

        return all_ok

    def verify_security(self):
        """Verifica configuraciones de seguridad"""
        print("üîí Verificando configuraciones de seguridad...")

        all_ok = True

        # Verificar archivos de configuraci√≥n de seguridad
        security_files = [
            "interface/backend/.env",
            "interface/backend/config.env",
            "modules/security",
        ]

        for file_path in security_files:
            if os.path.exists(file_path):
                if os.path.isdir(file_path):
                    file_count = len(list(Path(file_path).rglob("*.py")))
                    print(f"‚úÖ {file_path} - {file_count} archivos Python")
                else:
                    size = os.path.getsize(file_path)
                    print(f"‚úÖ {file_path} - {size} bytes")
            else:
                print(f"‚ö†Ô∏è {file_path} - No encontrado")

        # Verificar m√≥dulos de seguridad
        security_modules = ["modules.security", "modules.tokens", "modules.blockchain"]

        for module in security_modules:
            try:
                result = subprocess.run(
                    f'python3 -c \'import sys; sys.path.append("."); import {module}; print("OK")\'',
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )
                if result.returncode == 0 and "OK" in result.stdout:
                    print(f"‚úÖ {module} - Importa correctamente")
                else:
                    print(f"‚ùå {module} - Error al importar")
                    all_ok = False
            except Exception as e:
                print(f"‚ùå {module} - Error: {e}")
                all_ok = False

        return all_ok

    def verify_monitoring(self):
        """Verifica sistemas de monitoreo"""
        print("üìä Verificando sistemas de monitoreo...")

        all_ok = True

        # Verificar directorios de monitoreo
        monitoring_dirs = ["monitoring", "logs"]

        for dir_name in monitoring_dirs:
            dir_path = self.project_root / dir_name
            if dir_path.exists():
                file_count = len(list(dir_path.rglob("*.py")))
                print(f"‚úÖ {dir_name} - {file_count} archivos Python")
            else:
                print(f"‚ùå {dir_name} - No encontrado")
                all_ok = False

        # Verificar m√≥dulos de monitoreo
        monitoring_modules = [
            "monitoring.metrics_collector",
            "monitoring.alert_manager",
            "monitoring.monitoring_dashboard",
        ]

        for module in monitoring_modules:
            try:
                result = subprocess.run(
                    f'python3 -c \'import sys; sys.path.append("."); import {module}; print("OK")\'',
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )
                if result.returncode == 0 and "OK" in result.stdout:
                    print(f"‚úÖ {module} - Importa correctamente")
                else:
                    print(f"‚ùå {module} - Error al importar")
                    all_ok = False
            except Exception as e:
                print(f"‚ùå {module} - Error: {e}")
                all_ok = False

        return all_ok

    def generate_production_report(self):
        """Genera un reporte de preparaci√≥n para producci√≥n"""
        print("üìä Generando reporte de producci√≥n...")

        # Ejecutar todas las verificaciones
        checks = {
            "dependencies": self.verify_dependencies(),
            "llm_models": self.verify_llm_models(),
            "backend_functionality": self.verify_backend_functionality(),
            "frontend_functionality": self.verify_frontend_functionality(),
            "training_systems": self.verify_training_systems(),
            "endpoints": self.verify_endpoints(),
            "database_initialization": self.verify_database_initialization(),
            "docker_setup": self.verify_docker_setup(),
            "script_functionality": self.verify_script_functionality(),
            "module_imports": self.verify_module_imports(),
            "configurations": self.verify_configurations(),
            "security": self.verify_security(),
            "monitoring": self.verify_monitoring(),
        }

        report = {
            "timestamp": datetime.now().isoformat(),
            "project_root": str(self.project_root),
            "duration_seconds": (datetime.now() - self.start_time).total_seconds(),
            "checks": checks,
        }

        # Calcular puntuaci√≥n general
        total_checks = len(checks)
        passed_checks = sum(checks.values())
        score = (passed_checks / total_checks) * 100

        report["score"] = score
        report["status"] = (
            "READY" if score >= 85 else "NEEDS_WORK" if score >= 70 else "NOT_READY"
        )

        # Guardar reporte
        report_path = self.project_root / "PRODUCTION_READINESS_REPORT_COMPLETE.json"
        with open(report_path, "w") as f:
            json.dump(report, f, indent=2)

        print(f"‚úÖ Reporte guardado en: {report_path}")
        return report

    def print_summary(self, report):
        """Imprime un resumen del reporte"""
        print("\n" + "=" * 70)
        print("üöÄ REPORTE COMPLETO DE PREPARACI√ìN PARA PRODUCCI√ìN")
        print("=" * 70)

        print(f"üìÖ Fecha: {report['timestamp']}")
        print(f"üìÅ Proyecto: {report['project_root']}")
        print(f"‚è±Ô∏è Duraci√≥n: {report['duration_seconds']:.1f} segundos")
        print()

        print("üîç VERIFICACIONES DETALLADAS:")
        for check, result in report["checks"].items():
            status = "‚úÖ PAS√ì" if result else "‚ùå FALL√ì"
            check_name = check.replace("_", " ").title()
            print(f"   {check_name}: {status}")

        print()
        print(f"üìä PUNTUACI√ìN: {report['score']:.1f}/100")
        print(f"üéØ ESTADO: {report['status']}")

        if report["status"] == "READY":
            print("\nüéâ ¬°El sistema est√° listo para producci√≥n!")
            print("‚úÖ Todas las verificaciones cr√≠ticas han pasado")
            print("‚úÖ LLMs est√°n configurados y funcionando")
            print("‚úÖ Frontend y backend est√°n operativos")
            print("‚úÖ Sistemas de entrenamiento est√°n listos")
            print("‚úÖ Endpoints y APIs est√°n funcionando")
            print("‚úÖ Seguridad y monitoreo est√°n configurados")
        elif report["status"] == "NEEDS_WORK":
            print("\n‚ö†Ô∏è El sistema necesita trabajo antes de producci√≥n")
            print("üîß Revisa las verificaciones que fallaron")
            print("üîß Completa las configuraciones faltantes")
            print("üîß Optimiza el rendimiento donde sea necesario")
        else:
            print("\nüö® El sistema NO est√° listo para producci√≥n")
            print("‚ùå Muchas verificaciones cr√≠ticas fallaron")
            print("‚ùå Necesita trabajo significativo")

        print("\n" + "=" * 70)

    def run_production_preparation(self):
        """Ejecuta toda la preparaci√≥n para producci√≥n"""
        print("üöÄ Iniciando preparaci√≥n completa para producci√≥n...")
        print("=" * 70)

        # Ejecutar verificaciones
        report = self.generate_production_report()

        # Mostrar resumen
        self.print_summary(report)

        return report


def main():
    preparer = ProductionPreparer()
    report = preparer.run_production_preparation()

    # Retornar c√≥digo de salida apropiado
    if report["status"] == "READY":
        sys.exit(0)
    elif report["status"] == "NEEDS_WORK":
        sys.exit(1)
    else:
        sys.exit(2)


if __name__ == "__main__":
    main()
